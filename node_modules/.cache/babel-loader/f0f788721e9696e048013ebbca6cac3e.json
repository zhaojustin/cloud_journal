{"ast":null,"code":"\"use strict\";\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\n\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n  if (callbackArgIndex === void 0) {\n    callbackArgIndex = void 0;\n  }\n  /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n\n\n  return function () {\n    var callArgs = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      callArgs[_i] = arguments[_i];\n    }\n\n    var thisCallbackArgIndex;\n\n    if (callbackArgIndex === void 0) {\n      // istanbul ignore next\n      thisCallbackArgIndex = callArgs.length > 0 ? callArgs.length - 1 : 0;\n    } else {\n      thisCallbackArgIndex = callbackArgIndex;\n    }\n\n    var callbackArg = callArgs[thisCallbackArgIndex];\n\n    if (typeof callbackArg === 'function') {\n      fn.apply(context, callArgs);\n      return void 0;\n    } else {\n      var args_1 = []; // If an explicit callbackArgIndex is set, but the function is called\n      // with too few arguments, we want to push undefined onto args so that\n      // our constructed callback ends up at the right index.\n\n      var argLen = Math.max(callArgs.length, thisCallbackArgIndex);\n\n      for (var i = 0; i < argLen; i++) {\n        args_1.push(callArgs[i]);\n      }\n\n      return new Promise(function (resolve, reject) {\n        args_1.push(function (err, result) {\n          if (err) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n        });\n        fn.apply(context, args_1);\n      });\n    }\n  };\n}\n\nmodule.exports = callbackToPromise;","map":{"version":3,"sources":["../src/callback_to_promise.ts"],"names":[],"mappings":";AAAA;;;;;AAKG;;AACH;;AACA,SAAS,iBAAT,CAA2B,EAA3B,EAAoC,OAApC,EAAkD,gBAAlD,EAAmF;AAAjC,MAAA,gBAAA,KAAA,KAAA,CAAA,EAAA;AAAA,IAAA,gBAAA,GAAA,KAAgC,CAAhC;AAAiC;AAC/E;;;AACA,SAAO,YAAA;AAAS,QAAA,QAAA,GAAA,EAAA;;SAAA,IAAA,EAAA,GAAA,C,EAAA,EAAA,GAAA,SAAA,CAAA,M,EAAA,EAAA,E,EAAsB;AAAtB,MAAA,QAAA,CAAA,EAAA,CAAA,GAAA,SAAA,CAAA,EAAA,CAAA;;;AACZ,QAAI,oBAAJ;;AACA,QAAI,gBAAgB,KAAK,KAAK,CAA9B,EAAiC;AAC7B;AACA,MAAA,oBAAoB,GAAG,QAAQ,CAAC,MAAT,GAAkB,CAAlB,GAAsB,QAAQ,CAAC,MAAT,GAAkB,CAAxC,GAA4C,CAAnE;AACH,KAHD,MAGO;AACH,MAAA,oBAAoB,GAAG,gBAAvB;AACH;;AACD,QAAM,WAAW,GAAG,QAAQ,CAAC,oBAAD,CAA5B;;AACA,QAAI,OAAO,WAAP,KAAuB,UAA3B,EAAuC;AACnC,MAAA,EAAE,CAAC,KAAH,CAAS,OAAT,EAAkB,QAAlB;AACA,aAAO,KAAK,CAAZ;AACH,KAHD,MAGO;AACH,UAAM,MAAI,GAAG,EAAb,CADG,CAEH;AACA;AACA;;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,MAAlB,EAA0B,oBAA1B,CAAf;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,MAApB,EAA4B,CAAC,EAA7B,EAAiC;AAC7B,QAAA,MAAI,CAAC,IAAL,CAAU,QAAQ,CAAC,CAAD,CAAlB;AACH;;AACD,aAAO,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAgB;AAC/B,QAAA,MAAI,CAAC,IAAL,CAAU,UAAC,GAAD,EAAM,MAAN,EAAY;AAClB,cAAI,GAAJ,EAAS;AACL,YAAA,MAAM,CAAC,GAAD,CAAN;AACH,WAFD,MAEO;AACH,YAAA,OAAO,CAAC,MAAD,CAAP;AACH;AACJ,SAND;AAOA,QAAA,EAAE,CAAC,KAAH,CAAS,OAAT,EAAkB,MAAlB;AACH,OATM,CAAP;AAUH;AACJ,GAhCD;AAiCH;;AAED,MAAA,CAAA,OAAA,GAAS,iBAAT","sourcesContent":["\"use strict\";\n/**\n * Given a function fn that takes a callback as its last argument, returns\n * a new version of the function that takes the callback optionally. If\n * the function is not called with a callback for the last argument, the\n * function will return a promise instead.\n */\n/* eslint-disable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\nfunction callbackToPromise(fn, context, callbackArgIndex) {\n    if (callbackArgIndex === void 0) { callbackArgIndex = void 0; }\n    /* eslint-enable @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types */\n    return function () {\n        var callArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            callArgs[_i] = arguments[_i];\n        }\n        var thisCallbackArgIndex;\n        if (callbackArgIndex === void 0) {\n            // istanbul ignore next\n            thisCallbackArgIndex = callArgs.length > 0 ? callArgs.length - 1 : 0;\n        }\n        else {\n            thisCallbackArgIndex = callbackArgIndex;\n        }\n        var callbackArg = callArgs[thisCallbackArgIndex];\n        if (typeof callbackArg === 'function') {\n            fn.apply(context, callArgs);\n            return void 0;\n        }\n        else {\n            var args_1 = [];\n            // If an explicit callbackArgIndex is set, but the function is called\n            // with too few arguments, we want to push undefined onto args so that\n            // our constructed callback ends up at the right index.\n            var argLen = Math.max(callArgs.length, thisCallbackArgIndex);\n            for (var i = 0; i < argLen; i++) {\n                args_1.push(callArgs[i]);\n            }\n            return new Promise(function (resolve, reject) {\n                args_1.push(function (err, result) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(result);\n                    }\n                });\n                fn.apply(context, args_1);\n            });\n        }\n    };\n}\nmodule.exports = callbackToPromise;\n"]},"metadata":{},"sourceType":"script"}