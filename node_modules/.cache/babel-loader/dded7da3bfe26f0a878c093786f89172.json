{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\n\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\n\nvar record_1 = __importDefault(require(\"./record\"));\n\nvar callback_to_promise_1 = __importDefault(require(\"./callback_to_promise\"));\n\nvar has_1 = __importDefault(require(\"./has\"));\n\nvar query_params_1 = require(\"./query_params\");\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n *\n * Params should be validated prior to being passed to Query\n * with `Query.validateParams`.\n */\n\n\nvar Query =\n/** @class */\nfunction () {\n  function Query(table, params) {\n    this._table = table;\n    this._params = params;\n    this.firstPage = callback_to_promise_1.default(firstPage, this);\n    this.eachPage = callback_to_promise_1.default(eachPage, this, 1);\n    this.all = callback_to_promise_1.default(all, this);\n  }\n  /**\n   * Validates the parameters for passing to the Query constructor.\n   *\n   * @params {object} params parameters to validate\n   *\n   * @return an object with two keys:\n   *  validParams: the object that should be passed to the constructor.\n   *  ignoredKeys: a list of keys that will be ignored.\n   *  errors: a list of error messages.\n   */\n\n\n  Query.validateParams = function (params) {\n    var validParams = {};\n    var ignoredKeys = [];\n    var errors = [];\n\n    for (var _i = 0, _a = keys_1.default(params); _i < _a.length; _i++) {\n      var key = _a[_i];\n      var value = params[key];\n\n      if (has_1.default(Query.paramValidators, key)) {\n        var validator = Query.paramValidators[key];\n        var validationResult = validator(value);\n\n        if (validationResult.pass) {\n          validParams[key] = value;\n        } else {\n          errors.push(validationResult.error);\n        }\n      } else {\n        ignoredKeys.push(key);\n      }\n    }\n\n    return {\n      validParams: validParams,\n      ignoredKeys: ignoredKeys,\n      errors: errors\n    };\n  };\n\n  Query.paramValidators = query_params_1.paramValidators;\n  return Query;\n}();\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\n\n\nfunction firstPage(done) {\n  if (!isFunction_1.default(done)) {\n    throw new Error('The first parameter to `firstPage` must be a function');\n  }\n\n  this.eachPage(function (records) {\n    done(null, records);\n  }, function (error) {\n    done(error, null);\n  });\n}\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\n\n\nfunction eachPage(pageCallback, done) {\n  var _this = this;\n\n  if (!isFunction_1.default(pageCallback)) {\n    throw new Error('The first parameter to `eachPage` must be a function');\n  }\n\n  if (!isFunction_1.default(done) && done !== void 0) {\n    throw new Error('The second parameter to `eachPage` must be a function or undefined');\n  }\n\n  var path = \"/\" + this._table._urlEncodedNameOrId();\n\n  var params = __assign({}, this._params);\n\n  var inner = function () {\n    _this._table._base.runAction('get', path, params, null, function (err, response, result) {\n      if (err) {\n        done(err, null);\n      } else {\n        var next = void 0;\n\n        if (result.offset) {\n          params.offset = result.offset;\n          next = inner;\n        } else {\n          next = function () {\n            done(null);\n          };\n        }\n\n        var records = result.records.map(function (recordJson) {\n          return new record_1.default(_this._table, null, recordJson);\n        });\n        pageCallback(records, next);\n      }\n    });\n  };\n\n  inner();\n}\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\n\n\nfunction all(done) {\n  if (!isFunction_1.default(done)) {\n    throw new Error('The first parameter to `all` must be a function');\n  }\n\n  var allRecords = [];\n  this.eachPage(function (pageRecords, fetchNextPage) {\n    allRecords.push.apply(allRecords, pageRecords);\n    fetchNextPage();\n  }, function (err) {\n    if (err) {\n      done(err, null);\n    } else {\n      done(null, allRecords);\n    }\n  });\n}\n\nmodule.exports = Query;","map":{"version":3,"sources":["../src/query.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\nvar keys_1 = __importDefault(require(\"lodash/keys\"));\nvar record_1 = __importDefault(require(\"./record\"));\nvar callback_to_promise_1 = __importDefault(require(\"./callback_to_promise\"));\nvar has_1 = __importDefault(require(\"./has\"));\nvar query_params_1 = require(\"./query_params\");\n/**\n * Builds a query object. Won't fetch until `firstPage` or\n * or `eachPage` is called.\n *\n * Params should be validated prior to being passed to Query\n * with `Query.validateParams`.\n */\nvar Query = /** @class */ (function () {\n    function Query(table, params) {\n        this._table = table;\n        this._params = params;\n        this.firstPage = callback_to_promise_1.default(firstPage, this);\n        this.eachPage = callback_to_promise_1.default(eachPage, this, 1);\n        this.all = callback_to_promise_1.default(all, this);\n    }\n    /**\n     * Validates the parameters for passing to the Query constructor.\n     *\n     * @params {object} params parameters to validate\n     *\n     * @return an object with two keys:\n     *  validParams: the object that should be passed to the constructor.\n     *  ignoredKeys: a list of keys that will be ignored.\n     *  errors: a list of error messages.\n     */\n    Query.validateParams = function (params) {\n        var validParams = {};\n        var ignoredKeys = [];\n        var errors = [];\n        for (var _i = 0, _a = keys_1.default(params); _i < _a.length; _i++) {\n            var key = _a[_i];\n            var value = params[key];\n            if (has_1.default(Query.paramValidators, key)) {\n                var validator = Query.paramValidators[key];\n                var validationResult = validator(value);\n                if (validationResult.pass) {\n                    validParams[key] = value;\n                }\n                else {\n                    errors.push(validationResult.error);\n                }\n            }\n            else {\n                ignoredKeys.push(key);\n            }\n        }\n        return {\n            validParams: validParams,\n            ignoredKeys: ignoredKeys,\n            errors: errors,\n        };\n    };\n    Query.paramValidators = query_params_1.paramValidators;\n    return Query;\n}());\n/**\n * Fetches the first page of results for the query asynchronously,\n * then calls `done(error, records)`.\n */\nfunction firstPage(done) {\n    if (!isFunction_1.default(done)) {\n        throw new Error('The first parameter to `firstPage` must be a function');\n    }\n    this.eachPage(function (records) {\n        done(null, records);\n    }, function (error) {\n        done(error, null);\n    });\n}\n/**\n * Fetches each page of results for the query asynchronously.\n *\n * Calls `pageCallback(records, fetchNextPage)` for each\n * page. You must call `fetchNextPage()` to fetch the next page of\n * results.\n *\n * After fetching all pages, or if there's an error, calls\n * `done(error)`.\n */\nfunction eachPage(pageCallback, done) {\n    var _this = this;\n    if (!isFunction_1.default(pageCallback)) {\n        throw new Error('The first parameter to `eachPage` must be a function');\n    }\n    if (!isFunction_1.default(done) && done !== void 0) {\n        throw new Error('The second parameter to `eachPage` must be a function or undefined');\n    }\n    var path = \"/\" + this._table._urlEncodedNameOrId();\n    var params = __assign({}, this._params);\n    var inner = function () {\n        _this._table._base.runAction('get', path, params, null, function (err, response, result) {\n            if (err) {\n                done(err, null);\n            }\n            else {\n                var next = void 0;\n                if (result.offset) {\n                    params.offset = result.offset;\n                    next = inner;\n                }\n                else {\n                    next = function () {\n                        done(null);\n                    };\n                }\n                var records = result.records.map(function (recordJson) {\n                    return new record_1.default(_this._table, null, recordJson);\n                });\n                pageCallback(records, next);\n            }\n        });\n    };\n    inner();\n}\n/**\n * Fetches all pages of results asynchronously. May take a long time.\n */\nfunction all(done) {\n    if (!isFunction_1.default(done)) {\n        throw new Error('The first parameter to `all` must be a function');\n    }\n    var allRecords = [];\n    this.eachPage(function (pageRecords, fetchNextPage) {\n        allRecords.push.apply(allRecords, pageRecords);\n        fetchNextPage();\n    }, function (err) {\n        if (err) {\n            done(err, null);\n        }\n        else {\n            done(null, allRecords);\n        }\n    });\n}\nmodule.exports = Query;\n"]},"metadata":{},"sourceType":"script"}